<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thesaurus</title>

    <script type="text/javascript" src="/FichiersWebGL/WebGL.js"></script>
    <script type="text/javascript" src="/FichiersWebGL/ShaderCouleursTextures.js"></script>
    <script type="text/javascript" src="/FichiersWebGL/glMatrix-0.9.5.min.js"></script>
    <script type="text/javascript" src="/FichiersWebGL/Transformations.js"></script>
    <script type="text/javascript" src="/FichiersWebGL/Camera.js"></script>
    <script type="text/javascript" src="/FichiersWebGL/Textures.js"></script>
    <script type="text/javascript" src="Map.js"></script>
    <script type="text/javascript" src="Plafond.js"></script>
    <script type="text/javascript" src="Mur.js"></script>
    <script type="text/javascript" src="IndicateurMap.js"></script>
    <script type="text/javascript" src="Sol.js"></script>
    <script type="text/javascript" src="TeleTransporteur.js"></script>
    <script type="text/javascript" src="TeleRecepteur.js"></script>

    <script type="text/javascript">

        let objgl = null;
        let objProgShaders = null;
        let objScene3D = null;
        let score = 300;
        let temps = 60;

        const tabImages = ['/Textures/Transparent.gif', '/Textures/planks_spruce.png', '/Textures/Ciel.png',
            '/Textures/stonebrick_mossy.png', '/Textures/sandstone_normal.png'
            , '/Textures/beacon.png', '/Textures/purpur_pillar_top.png'];
        const TEX_TRANSPARENT = 0;
        const TEX_SOL = 1;
        const TEX_CIEL = 2;
        const TEX_MUR = 3;
        const TEX_MUR_OUVRABLE = 4
        const TEX_TELETRANS = 5;
        const TEX_TELERECP = 6;

        let tempsRestant = null;
        let penaliteVueAerienne = null;
        let jeuTermine = false;
        let cameraSauvPos = null;
        let cameraSauvTarget = null;
        let estEnVueMap = false;
        let posJoueur = null;
        let cibleJoueur = null;
        let posJoueurLive = null;
        let cibleJoueurLive = null;

        async function demarrer() {
            const objCanvas = document.getElementById('monCanvas');
            objgl = initWebGL(objCanvas);
            objProgShaders = initShaders(objgl);
            objScene3D = await initScene3D(objgl);

            effacerCanevas(objgl);
            dessiner(objgl, objProgShaders, objScene3D);
            demarrerCompteARebours();
        }
        async function initScene3D(objgl) {
            const objScene3D = new Object();
            const tabObjets3D = new Array();


            objScene3D.textures = await creerTextures(objgl, tabImages);
            objScene3D.teleporteurs = [];
            objScene3D.recepteurs = [];


            const obj3DSol = creerObj3DSol(objgl, TEX_SOL);
            const obj3DPlafond = creerObj3DPlafond(objgl, TEX_CIEL, 2.3); //tu peut regler l'hauteur
            tabObjets3D.push(obj3DPlafond);
            objScene3D.plafond = obj3DPlafond;
            tabObjets3D.push(obj3DSol);

            //Generation des murs ouvrables et non ouvrables
            for (let z = 0; z < map.length; z++) {
                for (let x = 0; x < map[z].length; x++) {
                    const cellule = map[z][x];

                    if (cellule === "b") {
                        const mur = creerObj3DMur(objgl, TEX_MUR, 2.5); // non ouvrable 
                        setPositionX(x, mur.transformations);
                        setPositionZ(z, mur.transformations);
                        setPositionY(0, mur.transformations);
                        tabObjets3D.push(mur);
                    }

                    if (cellule === "w" || cellule === "d") {
                        const mur = creerObj3DMur(objgl, TEX_MUR_OUVRABLE, 2.5); // ouvrable 
                        setPositionX(x, mur.transformations);
                        setPositionZ(z, mur.transformations);
                        setPositionY(0, mur.transformations);
                        tabObjets3D.push(mur);
                    }
                }
            }
            placerTeleporteursEtRecepteurs(objgl, objScene3D, TEX_TELETRANS, tabObjets3D);
            // Mettre les objets 3D sur la scène
            objScene3D.tabObjets3D = tabObjets3D;

            // La caméra
            let spawnX = 0, spawnZ = 0;
            const camera = creerCamera();
            for (let z = 0; z < map.length; z++) {
                for (let x = 0; x < map[z].length; x++) {
                    if (map[z][x] === "A") {
                        spawnX = x;
                        spawnZ = z;
                        break;
                    }
                }
                if (map[spawnZ][spawnX] === "A") break;
            }

            spawnX += 0.5; // pour centrer la caméra sur le "A"
            spawnZ += 0.5; // pour centrer la caméra sur le "A"

            // Positionner la caméra sur le "A"
            setPositionsCameraXYZ([spawnX, 0.6, spawnZ], camera);
            setCiblesCameraXYZ([spawnX, 0.6, spawnZ - 0.5], camera);
            posJoueur = [spawnX, 0.6, spawnZ];
            cibleJoueur = [spawnX, 0.6, spawnZ - 0.5];

            setOrientationsXYZ([0, 1, 0], camera);
            objScene3D.camera = camera;

            const indicateur = creerObj3DIndicateur(objgl);
            tabObjets3D.push(indicateur);
            objScene3D.indicateur = indicateur;

            return objScene3D;
        }
        function demarrerCompteARebours() {
            if (tempsRestant === null) {
                tempsRestant = setInterval(() => {
                    if (temps > 0) {
                        temps--;
                        document.getElementById("temps").innerText = `Temps : ${temps}`;
                    } else {
                        clearInterval(tempsRestant);
                        tempsRestant = null;
                        jeuTermine = true;

                        document.getElementById("messageGameOver").style.display = "block";
                        document.getElementById("sonGameOver").play();

                        retournerAuSpawn();
                    }
                }, 1000);
            }
        }
        function demarrerPenaliteScoreVueAerienne() {
            if (penaliteVueAerienne === null) {
                penaliteVueAerienne = setInterval(() => {
                    score = Math.max(0, score - 10);
                    document.getElementById("score").innerText = `Score : ${score}`;

                    if (score === 0) {
                        clearInterval(penaliteVueAerienne);
                        penaliteVueAerienne = null;
                        ajusterHauteurPlafond(2.5);
                        if (cameraSauvPos && cameraSauvTarget && estEnVueMap) {
                            setPositionsCameraXYZ(cameraSauvPos, objScene3D.camera);
                            setCiblesCameraXYZ(cameraSauvTarget, objScene3D.camera);
                            setOrientationsXYZ([0, 1, 0], objScene3D.camera);
                            estEnVueMap = false;
                        }
                        effacerCanevas(objgl);
                        dessiner(objgl, objProgShaders, objScene3D);
                    }
                }, 1000);
            }
        }

        function arreterPenaliteScoreVueAerienne() {
            if (penaliteVueAerienne !== null) {
                clearInterval(penaliteVueAerienne);
                penaliteVueAerienne = null;
            }
        }

        function dessiner(objgl, objProgShaders, objScene3D) {
            // La vue
            objgl.viewport(0, 0, objgl.drawingBufferWidth, objgl.drawingBufferHeight);
            if (estEnVueMap && objScene3D.indicateur) {
                const pos = posJoueurLive;
                const cible = cibleJoueurLive;
                console.log(pos);
                const dx = cible[0] - pos[0];
                const dz = cible[2] - pos[2];
                const angle = Math.atan2(dx, dz) * 180 / Math.PI;

                setPositionX(pos[0], objScene3D.indicateur.transformations);
                setPositionZ(pos[2], objScene3D.indicateur.transformations);
                setPositionY(1, objScene3D.indicateur.transformations);
                setAngleY(angle, objScene3D.indicateur.transformations);
            } else {
                //pour ne pas voir l'indicateur quand nous somme en vue premiere personne
                setPositionY(-1, objScene3D.indicateur.transformations);
            }

            // Matrice de projection
            const matProjection = mat4.create();
            const fltRapportCanevas = objgl.drawingBufferWidth / objgl.drawingBufferHeight;
            mat4.perspective(45, fltRapportCanevas, 0.01, 100, matProjection);

            // Relier la matrice aux shaders
            objgl.uniformMatrix4fv(objProgShaders.matProjection, false, matProjection);

            for (let i = 0; i < objScene3D.tabObjets3D.length; i++) {
                //if (objScene3D.tabObjets3D[i].estIndicateur && !estEnVueMap) continue;

                const vertex = objScene3D.tabObjets3D[i].vertex;
                const couleurs = objScene3D.tabObjets3D[i].couleurs;
                const texels = objScene3D.tabObjets3D[i].texels;
                const maillage = objScene3D.tabObjets3D[i].maillage;
                const transformations = objScene3D.tabObjets3D[i].transformations;

                // Matrice du modèle            
                const matModeleVue = mat4.create();
                mat4.identity(matModeleVue);

                // Placer la caméra sur la scène
                mat4.lookAt(getPositionsCameraXYZ(objScene3D.camera),
                    getCiblesCameraXYZ(objScene3D.camera),
                    getOrientationsXYZ(objScene3D.camera),
                    matModeleVue);

                // Appliquer les transformations sur le modèle 
                mat4.translate(matModeleVue, getPositionsXYZ(transformations));
                mat4.scale(matModeleVue, getEchellesXYZ(transformations));
                mat4.rotateX(matModeleVue, getAngleX(transformations) * Math.PI / 180);
                mat4.rotateY(matModeleVue, getAngleY(transformations) * Math.PI / 180);
                mat4.rotateZ(matModeleVue, getAngleZ(transformations) * Math.PI / 180);

                // Relier la matrice aux shaders
                objgl.uniformMatrix4fv(objProgShaders.matModeleVue, false, matModeleVue);

                if (maillage == null)
                    // Dessiner les sous-objets
                    for (let j = 0; j < vertex.length; j++) {

                        // Relier les vertex aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex[j]);
                        objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);
                        const intNbVertex = (objgl.getBufferParameter(objgl.ARRAY_BUFFER, objgl.BUFFER_SIZE) / 4) / 3;

                        // Relier les couleurs aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs[j]);
                        objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0);

                        // Activer la texture
                        objgl.activeTexture(objgl.TEXTURE0 + texels[j].intNoTexture);
                        objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels[j].intNoTexture]);

                        // Relier les texels aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, texels[j]);
                        objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                        // Relier le no de texture et le taux de couleur aux shaders                 
                        objgl.uniform1i(objProgShaders.noTexture, texels[j].intNoTexture);
                        objgl.uniform1f(objProgShaders.pcCouleurTexel, texels[j].pcCouleurTexel);

                        // Dessiner
                        objgl.drawArrays(vertex[j].typeDessin, 0, intNbVertex);
                    }
                else { // Dessiner le maillage

                    // Relier les vertex aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex);
                    objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);

                    // Relier les couleurs aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs);
                    objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0)

                    // Activer la texture
                    objgl.activeTexture(objgl.TEXTURE0 + texels.intNoTexture);
                    objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels.intNoTexture]);

                    // Relier les texels aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, texels);
                    objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                    // Relier le no de texture et le taux de couleur aux shaders                 
                    objgl.uniform1i(objProgShaders.noTexture, texels.intNoTexture);
                    objgl.uniform1f(objProgShaders.pcCouleurTexel, texels.pcCouleurTexel);

                    // Sélectionner le maillage qu'on va utiliser pour les triangles et les droites
                    objgl.bindBuffer(objgl.ELEMENT_ARRAY_BUFFER, maillage);

                    // Dessiner les triangles
                    objgl.drawElements(objgl.TRIANGLES, maillage.intNbTriangles * 3, objgl.UNSIGNED_SHORT, 0);
                    // Dessiner les droites à la suite des triangles
                    objgl.drawElements(objgl.LINES, maillage.intNbDroites * 2, objgl.UNSIGNED_SHORT, maillage.intNbTriangles * 2 * 3);
                }
            }
        }

        function effacerCanevas(objgl) {

            objgl.clearColor(0.0, 0.0, 0.0, 1.0);

            objgl.clear(objgl.COLOR_BUFFER_BIT | objgl.DEPTH_BUFFER_BIT);
        }


        function deplacerCamera() {
            const camera = objScene3D.camera;
            if (jeuTermine) return;
            let fltX;
            let fltZ;
            let intDirection;
            let fltAngle;
            let fltXPrime;
            let fltZPrime;
            let fltRayon;
            //On va changer les page up and page down apres quon finit tout
            //Page Up -> map view
            if (event.key === "1" && !estEnVueMap) {
                demarrerPenaliteScoreVueAerienne();
                cameraSauvPos = [...getPositionsCameraXYZ(camera)];
                cameraSauvTarget = [...getCiblesCameraXYZ(camera)];
                estEnVueMap = true;
                posJoueurLive = getPositionsCameraXYZ(objScene3D.camera);
                cibleJoueurLive = getCiblesCameraXYZ(objScene3D.camera);
                setPositionsCameraXYZ([15.5, 40, 15.5], camera); // centrer et elever
                setCiblesCameraXYZ([15.5, 0, 15.5], camera); // regarde vers le bas
                setOrientationsXYZ([0, 0, -1], camera); // vers le sol

                ajusterHauteurPlafond(100);
                effacerCanevas(objgl);
                dessiner(objgl, objProgShaders, objScene3D);
                return;
            }
            // Page Down -> Retour caméra joueur
            if (event.key === "2") {
                arreterPenaliteScoreVueAerienne();
                ajusterHauteurPlafond(0);
                if (cameraSauvPos && cameraSauvTarget && estEnVueMap) {
                    setPositionsCameraXYZ(cameraSauvPos, camera);
                    setCiblesCameraXYZ(cameraSauvTarget, camera);
                    setOrientationsXYZ([0, 1, 0], camera);
                    estEnVueMap = false;
                }

                effacerCanevas(objgl);
                dessiner(objgl, objProgShaders, objScene3D);
                return;
            }
            if (event.keyCode == 37 || event.keyCode == 39) {
                // 37:  Flèche-à-gauche; 39:Flèche-à-droite
                fltX = getCibleCameraX(camera) - getPositionCameraX(camera);
                fltZ = getCibleCameraZ(camera) - getPositionCameraZ(camera);
                intDirection = (event.keyCode == 37) ? -1 : 1;
                fltAngle = intDirection * Math.PI / 90; // Tourner 2 degrés
                fltXPrime = fltX * Math.cos(fltAngle) - fltZ * Math.sin(fltAngle);
                fltZPrime = fltX * Math.sin(fltAngle) + fltZ * Math.cos(fltAngle);
                setCibleCameraX(getPositionCameraX(camera) + fltXPrime, camera);
                setCibleCameraZ(getPositionCameraZ(camera) + fltZPrime, camera);
            }
            else if (event.keyCode == 38 || event.keyCode == 40) {
                const direction = (event.keyCode == 38) ? 1 : -1;

                let dx = getCibleCameraX(camera) - getPositionCameraX(camera);
                let dz = getCibleCameraZ(camera) - getPositionCameraZ(camera);
                const distance = Math.sqrt(dx * dx + dz * dz);

                dx /= distance;
                dz /= distance;

                const stepSize = 0.2 * direction;

                const newX = getPositionCameraX(camera) + dx * stepSize;
                const newZ = getPositionCameraZ(camera) + dz * stepSize;

                // Vérifier si le nouveau point est un mur
                // Si ce n'est pas un mur, mettre à jour la position de la caméra
                if (!estMur(newX, newZ)) {
                    setPositionCameraX(newX, camera);
                    setPositionCameraZ(newZ, camera);
                    setCibleCameraX(getCibleCameraX(camera) + dx * stepSize, camera);
                    setCibleCameraZ(getCibleCameraZ(camera) + dz * stepSize, camera);
                }
            }
            teleporterJoueurSiSurTeleporteur(objScene3D);

            effacerCanevas(objgl);
            dessiner(objgl, objProgShaders, objScene3D);
        }

        function placerTeleporteursEtRecepteurs(objgl, objScene3D, intNoTexture, tabObjets3D) {
            objScene3D.teleporteurs = [];
            objScene3D.recepteurs = [];

            const cellulesDisponibles = [];

            for (let z = 0; z < map.length; z++) {
                for (let x = 0; x < map[z].length; x++) {
                    const cellule = map[z][x];
                    if (cellule === "g") {
                        cellulesDisponibles.push({ x, z });
                    }
                }
            }

            // Mélange aléatoire
            for (let i = cellulesDisponibles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [cellulesDisponibles[i], cellulesDisponibles[j]] = [cellulesDisponibles[j], cellulesDisponibles[i]];
            }

            const nbTeleporteurs = 10;
            const nbRecepteurs = 10;
            let index = 0;

            const positionsUtilisees = new Set();

            // Placer les téléporteurs
            for (let i = 0; i < nbTeleporteurs && index < cellulesDisponibles.length; i++) {
                const { x, z } = cellulesDisponibles[index++];
                const key = `${x},${z}`;
                if (positionsUtilisees.has(key)) continue;

                const objTele = creerObj3DTeleTransporteur(objgl, TEX_TELETRANS);
                setPositionX(x + 0.5, objTele.transformations);
                setPositionZ(z + 0.5, objTele.transformations);
                setPositionY(0, objTele.transformations);
                tabObjets3D.push(objTele);
                objScene3D.teleporteurs.push({ x, z });
                positionsUtilisees.add(key);
            }

            // Placer les récepteurs
            for (let i = 0; i < nbRecepteurs && index < cellulesDisponibles.length; i++) {
                const { x, z } = cellulesDisponibles[index++];
                const key = `${x},${z}`;
                if (positionsUtilisees.has(key)) continue;

                const objRecepteur = creerObj3DTeleRecepteur(objgl, TEX_TELERECP);
                setPositionX(x + 0.5, objRecepteur.transformations);
                setPositionZ(z + 0.5, objRecepteur.transformations);
                setPositionY(0, objRecepteur.transformations);
                tabObjets3D.push(objRecepteur);
                objScene3D.recepteurs.push({ x, z });
                positionsUtilisees.add(key);
            }
        }


        function teleporterJoueurSiSurTeleporteur(objScene3D) {
            const camera = objScene3D.camera;
            const joueurX = Math.floor(getPositionCameraX(camera));
            const joueurZ = Math.floor(getPositionCameraZ(camera));

            for (let i = 0; i < objScene3D.teleporteurs.length; i++) {
                const tp = objScene3D.teleporteurs[i];
                if (Math.abs(joueurX + 0.5 - tp.x - 0.5) < 0.3 && Math.abs(joueurZ + 0.5 - tp.z - 0.5) < 0.3) {
                    if (objScene3D.recepteurs.length === 0) return;

                    const r = objScene3D.recepteurs[Math.floor(Math.random() * objScene3D.recepteurs.length)];

                    // Garder direction actuelle
                    const dx = getCibleCameraX(camera) - getPositionCameraX(camera);
                    const dz = getCibleCameraZ(camera) - getPositionCameraZ(camera);

                    setPositionCameraX(r.x + 0.5, camera);
                    setPositionCameraZ(r.z + 0.5, camera);
                    setCibleCameraX(r.x + 0.5 + dx, camera);
                    setCibleCameraZ(r.z + 0.5 + dz, camera);

                    //Son de téléportation
                    console.log("Téléportation");
                }
            }
        }


    </script>
</head>

<body onload="demarrer()">
    <canvas id="monCanvas" width="1920" height="1080" tabindex="1" onkeydown="deplacerCamera(); return false">
        Votre navigateur ne supporte pas la balise canvas
    </canvas>

    <div id="infoJeu"
        style="text-align: center; font-family: Arial, sans-serif; font-size: 20px; color: white; background-color: #333; padding: 10px; margin-top: 10px;">
        <span id="niveau">Niveau : 1</span> |
        <span id="ouvreurs">Ouvreurs : 4</span> |
        <span id="score">Score : 300</span> |
        <span id="temps">Temps : 60</span>
    </div>

    <!-- Ajoute aussi ça pour le son du Game Over -->
    <audio id="sonGameOver" src="Sons/gameover.mp3" preload="auto"></audio>

    <!-- Message Game Over caché au début -->
    <div id="messageGameOver" style="display: none;
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     font-size: 60px;
     color: red;
     background: rgba(0,0,0,0.8);
     padding: 30px;
     border: 5px solid red;
     border-radius: 15px;
     font-family: Arial, sans-serif;
     z-index: 999;">
        GAME OVER
    </div>
</body>

</html>